 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/assets/tokens.base.json b/mobile/assets/tokens.base.json
new file mode 100644
index 0000000000000000000000000000000000000000..224a9f6a0dcddad7faa723bd81b58196772f5fd5
--- /dev/null
+++ b/mobile/assets/tokens.base.json
@@ -0,0 +1,38 @@
+{
+  "chainIds": {
+    "base": 8453,
+    "baseSepolia": 84532
+  },
+  "tokens": [
+    {
+      "symbol": "USDC",
+      "name": "USD Coin",
+      "decimals": 6,
+      "addresses": {
+        "8453": "0x833589FCD6EDB6E08f4f06f8f219cA9a4ba62F14",
+        "84532": "0x5Fd55A1d8DDD313dFa9e5cEdc7A9389C9D75C3b0"
+      },
+      "features": {
+        "erc2612": false,
+        "permit2": true
+      }
+    },
+    {
+      "symbol": "WETH",
+      "name": "Wrapped Ether",
+      "decimals": 18,
+      "addresses": {
+        "8453": "0x4200000000000000000000000000000000000006",
+        "84532": "0x4200000000000000000000000000000000000006"
+      },
+      "features": {
+        "erc2612": false,
+        "permit2": false
+      }
+    }
+  ],
+  "permit2": {
+    "8453": "0x000000000022D473030F116dDEE9F6B43aC78BA3",
+    "84532": "0x000000000022D473030F116dDEE9F6B43aC78BA3"
+  }
+}
diff --git a/mobile/lib/models/token.dart b/mobile/lib/models/token.dart
new file mode 100644
index 0000000000000000000000000000000000000000..1a6a5bc1aa45fb23cdc9cf9733d4a19c8cd18869
--- /dev/null
+++ b/mobile/lib/models/token.dart
@@ -0,0 +1,40 @@
+import 'dart:convert';
+import 'package:flutter/services.dart' show rootBundle;
+
+class ChainTokens {
+  final Map<String, dynamic> raw;
+  ChainTokens(this.raw);
+
+  String? tokenAddress(String symbol, int chainId) {
+    final t = (raw['tokens'] as List).firstWhere(
+      (e) => e['symbol'] == symbol,
+      orElse: () => null,
+    );
+    if (t == null) return null;
+    return (t['addresses'] as Map)[chainId.toString()] as String?;
+  }
+
+  Map<String, dynamic>? token(String symbol) {
+    return (raw['tokens'] as List)
+        .cast<Map<String, dynamic>?>()
+        .firstWhere((e) => e?['symbol'] == symbol, orElse: () => null);
+  }
+
+  bool feature(String symbol, String name) {
+    final t = token(symbol);
+    if (t == null) return false;
+    return (t['features']?[name] ?? false) as bool;
+  }
+
+  String? permit2Address(int chainId) {
+    return (raw['permit2'] as Map)[chainId.toString()] as String?;
+  }
+
+  int chainIdBase() => (raw['chainIds']['base'] as num).toInt();
+  int chainIdBaseSepolia() => (raw['chainIds']['baseSepolia'] as num).toInt();
+
+  static Future<ChainTokens> load() async {
+    final s = await rootBundle.loadString('assets/tokens.base.json');
+    return ChainTokens(jsonDecode(s) as Map<String, dynamic>);
+  }
+}
diff --git a/mobile/lib/services/erc20.dart b/mobile/lib/services/erc20.dart
new file mode 100644
index 0000000000000000000000000000000000000000..b2596d1514e328c0b18a9e74be9c6c353cda21e9
--- /dev/null
+++ b/mobile/lib/services/erc20.dart
@@ -0,0 +1,72 @@
+import 'dart:typed_data';
+import 'package:web3dart/contracts.dart';
+import 'package:web3dart/web3dart.dart' as w3;
+
+class Erc20 {
+  static final _fnTransfer = ContractFunction(
+    'transfer',
+    [
+      FunctionParameter('to', AddressType()),
+      FunctionParameter('amount', UintType())
+    ],
+    outputs: [FunctionParameter('', BoolType())],
+  );
+
+  static final _fnApprove = ContractFunction(
+    'approve',
+    [
+      FunctionParameter('spender', AddressType()),
+      FunctionParameter('amount', UintType())
+    ],
+    outputs: [FunctionParameter('', BoolType())],
+  );
+
+  static final _fnPermit = ContractFunction(
+    'permit',
+    [
+      FunctionParameter('owner', AddressType()),
+      FunctionParameter('spender', AddressType()),
+      FunctionParameter('value', UintType()),
+      FunctionParameter('deadline', UintType()),
+      FunctionParameter('v', UintType(length: 8)),
+      FunctionParameter('r', FixedBytes(32)),
+      FunctionParameter('s', FixedBytes(32)),
+    ],
+    outputs: const [],
+  );
+
+  static Uint8List encodeTransfer(String to, BigInt amount) =>
+      _fnTransfer.encodeCall([
+        w3.EthereumAddress.fromHex(to),
+        amount,
+      ]);
+
+  static Uint8List encodeApprove(String spender, BigInt amount) =>
+      _fnApprove.encodeCall([
+        w3.EthereumAddress.fromHex(spender),
+        amount,
+      ]);
+
+  static Uint8List encodePermit({
+    required String owner,
+    required String spender,
+    required BigInt value,
+    required BigInt deadline,
+    required int v,
+    required Uint8List r,
+    required Uint8List s,
+  }) =>
+      _fnPermit.encodeCall([
+        w3.EthereumAddress.fromHex(owner),
+        w3.EthereumAddress.fromHex(spender),
+        value,
+        deadline,
+        BigInt.from(v),
+        r,
+        s,
+      ]);
+}
+
+class Permit2 {
+  // Placeholder for future Permit2 encoders
+}
diff --git a/mobile/lib/ui/send_token_sheet.dart b/mobile/lib/ui/send_token_sheet.dart
new file mode 100644
index 0000000000000000000000000000000000000000..8f8229de8c49cf12eca70b8e7c94fc97d0f152c2
--- /dev/null
+++ b/mobile/lib/ui/send_token_sheet.dart
@@ -0,0 +1,143 @@
+import 'package:flutter/material.dart';
+import '../models/token.dart';
+import '../userop/userop_flow.dart';
+import '../crypto/mnemonic.dart';
+import '../state/settings.dart';
+
+class SendTokenSheet extends StatefulWidget {
+  final Map<String, dynamic> cfg;
+  final UserOpFlow flow;
+  final KeyMaterial keys;
+  final AppSettings settings;
+  const SendTokenSheet({
+    super.key,
+    required this.cfg,
+    required this.flow,
+    required this.keys,
+    required this.settings,
+  });
+
+  @override
+  State<SendTokenSheet> createState() => _SendTokenSheetState();
+}
+
+class _SendTokenSheetState extends State<SendTokenSheet> {
+  ChainTokens? registry;
+  String selected = 'USDC';
+  final toCtrl = TextEditingController();
+  final amtCtrl = TextEditingController();
+  bool usePermit = false;
+  bool usePermit2 = false;
+  bool sending = false;
+
+  @override
+  void initState() {
+    super.initState();
+    ChainTokens.load().then((r) => setState(() => registry = r));
+  }
+
+  BigInt _pow10(int d) => BigInt.from(10).pow(d);
+
+  BigInt _parseAmount(String v, int decimals) {
+    final parts = v.split('.');
+    final whole = parts[0].isEmpty ? BigInt.zero : BigInt.parse(parts[0]);
+    var frac = parts.length > 1 ? parts[1] : '';
+    if (frac.length > decimals) {
+      frac = frac.substring(0, decimals);
+    }
+    final fracVal =
+        frac.isEmpty ? BigInt.zero : BigInt.parse(frac.padRight(decimals, '0'));
+    return whole * _pow10(decimals) + fracVal;
+  }
+
+  Future<void> _send() async {
+    if (registry == null) return;
+    final token = selected;
+    final tokenInfo = registry!.token(token)!;
+    final decimals = (tokenInfo['decimals'] as num).toInt();
+    final amount = _parseAmount(amtCtrl.text.trim(), decimals);
+    final to = toCtrl.text.trim();
+    setState(() => sending = true);
+    try {
+      await widget.flow.sendToken(
+        cfg: widget.cfg,
+        keys: widget.keys,
+        tokenSymbol: token,
+        recipient: to,
+        amountWeiLike: amount,
+        registry: registry!,
+        wantErc2612: usePermit,
+        wantPermit2: usePermit2,
+        settings: widget.settings,
+        log: (m) => debugPrint(m),
+        selectFees: (f) async => f,
+      );
+      if (mounted) Navigator.of(context).pop();
+    } catch (e) {
+      debugPrint('send error: $e');
+    } finally {
+      if (mounted) setState(() => sending = false);
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final tokens = registry?.raw['tokens'] as List? ?? [];
+    final permitDisabled = !(registry?.feature(selected, 'erc2612') ?? false);
+    final permit2Disabled =
+        registry?.permit2Address(widget.cfg['chainId'] as int) == null ||
+            !(registry?.feature(selected, 'permit2') ?? false);
+    return Scaffold(
+      appBar: AppBar(title: const Text('Send Token')),
+      body: registry == null
+          ? const Center(child: CircularProgressIndicator())
+          : Padding(
+              padding: const EdgeInsets.all(16),
+              child: Column(
+                children: [
+                  DropdownButton<String>(
+                    value: selected,
+                    items: tokens
+                        .map<DropdownMenuItem<String>>((e) => DropdownMenuItem(
+                              value: e['symbol'] as String,
+                              child: Text(e['symbol'] as String),
+                            ))
+                        .toList(),
+                    onChanged: (v) => setState(() => selected = v ?? selected),
+                  ),
+                  TextField(
+                    controller: toCtrl,
+                    decoration:
+                        const InputDecoration(labelText: 'Recipient (0x...)'),
+                  ),
+                  TextField(
+                    controller: amtCtrl,
+                    decoration: const InputDecoration(labelText: 'Amount'),
+                    keyboardType:
+                        const TextInputType.numberWithOptions(decimal: true),
+                  ),
+                  SwitchListTile(
+                    value: usePermit,
+                    onChanged: permitDisabled
+                        ? null
+                        : (v) => setState(() => usePermit = v),
+                    title: const Text('Use EIP-2612 permit'),
+                  ),
+                  SwitchListTile(
+                    value: usePermit2,
+                    onChanged: permit2Disabled
+                        ? null
+                        : (v) => setState(() => usePermit2 = v),
+                    title: const Text('Use Permit2'),
+                  ),
+                  const SizedBox(height: 16),
+                  ElevatedButton(
+                    onPressed: sending ? null : _send,
+                    child: const Text('Send'),
+                  ),
+                ],
+              ),
+            ),
+    );
+  }
+}
diff --git a/mobile/lib/userop/userop_flow.dart b/mobile/lib/userop/userop_flow.dart
index 7da5b7a8769f75e6e91f39cf6ba245ce26f8d7a6..4bcc86c2ca941b5a7d5f70dbb614e7bf72a8b270 100644
--- a/mobile/lib/userop/userop_flow.dart
+++ b/mobile/lib/userop/userop_flow.dart
@@ -1,40 +1,42 @@
 import 'dart:typed_data';
 import 'package:web3dart/crypto.dart' as w3;
 import 'package:web3dart/web3dart.dart';
 
 import '../crypto/mnemonic.dart';
 import '../crypto/wots.dart';
 import '../services/bundler_client.dart';
 import '../services/rpc.dart';
 import '../services/storage.dart';
 import '../services/biometric.dart';
 import '../services/entrypoint.dart';
 import '../state/fees.dart';
 import '../state/settings.dart';
 import '../userop/userop.dart';
 import '../userop/userop_signer.dart';
+import '../models/token.dart';
+import '../services/erc20.dart';
 
 class UserOpFlow {
   final RpcClient rpc;
   final BundlerClient bundler;
   final PendingIndexStore store;
 
   UserOpFlow({required this.rpc, required this.bundler, required this.store});
 
   Future<String> sendEth({
     required Map<String, dynamic> cfg,
     required KeyMaterial keys,
     required EthereumAddress to,
     required BigInt amountWei,
     required AppSettings settings,
     required void Function(String) log,
     required Future<FeeState?> Function(FeeState) selectFees,
   }) async {
     final chainId = cfg['chainId'] as int;
     final wallet = EthereumAddress.fromHex(cfg['walletAddress']);
     final entryPoint = EthereumAddress.fromHex(cfg['entryPoint']);
 
     // view function encodings
     const fnNonce = ContractFunction('nonce', [],
         outputs: [FunctionParameter('', UintType())]);
     const fnCurrent = ContractFunction('currentPkCommit', [],
@@ -216,34 +218,312 @@ class UserOpFlow {
       };
       if (pending != null && decision == 'rebuild') {
         record['createdAt'] = pending['createdAt'];
       }
       await store.save(chainId, wallet.hex, record);
     }
 
     final pendingStatus = pending == null ? 'absent' : 'present';
     log([
       'pendingIndex: $pendingStatus',
       'nonce(): ${nonceOnChain.toString()}',
       'userOpHash(draft): ${userOpHashHex.substring(0, 10)}',
       'decision: $decision',
     ].join('\n'));
 
     final uoh = await bundler.sendUserOperation(op.toJson(), entryPoint.hex);
     record ??= await store.load(chainId, wallet.hex);
     if (record != null) {
       record['status'] = 'sent';
       record['lastAttemptAt'] = now;
       await store.save(chainId, wallet.hex, record);
     }
     return uoh;
   }
 
+  Future<String> sendToken({
+    required Map<String, dynamic> cfg,
+    required KeyMaterial keys,
+    required String tokenSymbol,
+    required String recipient,
+    required BigInt amountWeiLike,
+    required ChainTokens registry,
+    required bool wantErc2612,
+    required bool wantPermit2,
+    required AppSettings settings,
+    required void Function(String) log,
+    required Future<FeeState?> Function(FeeState) selectFees,
+  }) async {
+    final chainId = cfg['chainId'] as int;
+    final wallet = EthereumAddress.fromHex(cfg['walletAddress']);
+    final entryPoint = EthereumAddress.fromHex(cfg['entryPoint']);
+
+    const fnNonce = ContractFunction('nonce', [],
+        outputs: [FunctionParameter('', UintType())]);
+    const fnCurrent = ContractFunction('currentPkCommit', [],
+        outputs: [FunctionParameter('', FixedBytes(32))]);
+    const fnNext = ContractFunction('nextPkCommit', [],
+        outputs: [FunctionParameter('', FixedBytes(32))]);
+    final dataNonce = fnNonce.encodeCall(const []);
+    final dataCur = fnCurrent.encodeCall(const []);
+    final dataNext = fnNext.encodeCall(const []);
+
+    final nonceHex = await rpc.callViewHex(
+        wallet.hex, '0x${w3.bytesToHex(dataNonce, include0x: false)}');
+    final curHex = await rpc.callViewHex(
+        wallet.hex, '0x${w3.bytesToHex(dataCur, include0x: false)}');
+    final nextHex = await rpc.callViewHex(
+        wallet.hex, '0x${w3.bytesToHex(dataNext, include0x: false)}');
+
+    BigInt parseHexBigInt(String h) {
+      final s = h.startsWith('0x') ? h.substring(2) : h;
+      return s.isEmpty ? BigInt.zero : BigInt.parse(s, radix: 16);
+    }
+
+    Uint8List parseHex32(String h) {
+      final b = w3.hexToBytes(h);
+      if (b.length == 32) return Uint8List.fromList(b);
+      if (b.length > 32) return Uint8List.fromList(b.sublist(b.length - 32));
+      final out = Uint8List(32);
+      out.setRange(32 - b.length, 32, b);
+      return out;
+    }
+
+    final nonceOnChain = parseHexBigInt(nonceHex);
+    final currentCommitOnChain = parseHex32(curHex);
+    final nextCommitOnChain = parseHex32(nextHex);
+    log('currentPkCommit: 0x${w3.bytesToHex(currentCommitOnChain, include0x: true)}');
+
+    final pending = await store.load(chainId, wallet.hex);
+    final callData = await buildTokenSendBatch(
+      chainId: chainId,
+      wallet: wallet.hex,
+      tokenSymbol: tokenSymbol,
+      recipient: recipient,
+      amountWeiLike: amountWeiLike,
+      wantErc2612: wantErc2612,
+      wantPermit2: wantPermit2,
+      registry: registry,
+    );
+
+    final op = UserOperation()
+      ..sender = wallet.hex
+      ..nonce = nonceOnChain
+      ..callData = callData;
+
+    final gas = await bundler.estimateUserOpGas(op.toJson(), entryPoint.hex);
+    op.callGasLimit = BigInt.parse(gas['callGasLimit'].toString());
+    op.verificationGasLimit =
+        BigInt.parse(gas['verificationGasLimit'].toString());
+    op.preVerificationGas = BigInt.parse(gas['preVerificationGas'].toString());
+
+    final fh = await rpc.feeHistory(5, [50]);
+    final baseFees = (fh['baseFeePerGas'] as List)
+        .map((h) => BigInt.parse(h.toString().substring(2), radix: 16))
+        .toList();
+    final baseFee = baseFees.isNotEmpty ? baseFees.last : BigInt.zero;
+
+    BigInt priority = BigInt.zero;
+    final rewards = fh['reward'] as List?;
+    if (rewards != null && rewards.isNotEmpty) {
+      final lastRewards = (rewards.last as List).cast<String>();
+      if (lastRewards.isNotEmpty) {
+        priority = BigInt.parse(lastRewards.first.substring(2), radix: 16);
+      }
+    }
+    if (priority == BigInt.zero) {
+      priority = await rpc.maxPriorityFeePerGas();
+    }
+    final suggestedMaxFee = baseFee + priority;
+
+    var fees = FeeState(
+      baseFee: baseFee,
+      prioritySuggestion: priority,
+      maxFeePerGas: suggestedMaxFee,
+      maxPriorityFeePerGas: priority,
+      preVerificationGas: op.preVerificationGas,
+      verificationGasLimit: op.verificationGasLimit,
+      callGasLimit: op.callGasLimit,
+      bundlerFeeWei: BigInt.zero,
+    );
+
+    final chosen = await selectFees(fees);
+    if (chosen == null) {
+      throw Exception('fee-canceled');
+    }
+    fees = chosen;
+
+    op.maxFeePerGas = fees.maxFeePerGas;
+    op.maxPriorityFeePerGas = fees.maxPriorityFeePerGas;
+
+    final ep = EntryPointService(rpc, entryPoint);
+    final userOpHash = await ep.getUserOpHash(op);
+    final userOpHashHex = '0x${w3.bytesToHex(userOpHash, include0x: false)}';
+
+    final mustAuth = settings.requireBiometricForChain(chainId);
+    if (mustAuth) {
+      final bio = BiometricService();
+      final can = await bio.canCheck();
+      if (!can) {
+        log('Biometric requested but unavailable. Aborting.');
+        throw Exception('biometric-unavailable');
+      }
+      final ok = await bio.authenticate(
+          reason: 'Authenticate to sign & send this transaction');
+      if (!ok) {
+        log('Authentication canceled/failed. Send aborted.');
+        throw Exception('auth-failed');
+      }
+      log('Authentication successful.');
+    }
+
+    final now = DateTime.now().toUtc().toIso8601String();
+    String decision;
+    Map<String, dynamic>? record = pending;
+
+    if (pending != null &&
+        pending['userOpHash'] == userOpHashHex &&
+        pending['index'] == nonceOnChain.toInt() &&
+        (pending['entryPoint'] as String).toLowerCase() ==
+            entryPoint.hex.toLowerCase() &&
+        pending['networkChainId'] == chainId) {
+      decision = 'reuse';
+      op.signature =
+          Uint8List.fromList(w3.hexToBytes(pending['signatureHybrid']));
+      pending['status'] = 'sent';
+      pending['lastAttemptAt'] = now;
+      await store.save(chainId, wallet.hex, pending);
+    } else {
+      if (pending != null && pending['index'] != nonceOnChain.toInt()) {
+        await store.clear(chainId, wallet.hex);
+        decision = 'stale-clear';
+      } else if (pending != null) {
+        decision = 'rebuild';
+      } else {
+        decision = 'fresh';
+      }
+
+      final creds = EthPrivateKey(Uint8List.fromList(keys.ecdsaPriv));
+      final sigBytes = await creds.signToUint8List(userOpHash, chainId: null);
+      final eSig = w3.MsgSignature(
+        w3.bytesToInt(sigBytes.sublist(0, 32)),
+        w3.bytesToInt(sigBytes.sublist(32, 64)),
+        sigBytes[64],
+      );
+
+      final index = nonceOnChain.toInt();
+      final seedI = hkdfIndex(Uint8List.fromList(keys.wotsMaster), index);
+      final (sk, pk) = Wots.keygen(seedI);
+      final wSig = Wots.sign(userOpHash, sk);
+
+      final confirmCommit = nextCommitOnChain;
+      final nextNextSeed =
+          hkdfIndex(Uint8List.fromList(keys.wotsMaster), index + 2);
+      final (_, nextNextPk) = Wots.keygen(nextNextSeed);
+      final proposeCommit = Wots.commitPk(nextNextPk);
+
+      op.signature =
+          packHybridSignature(eSig, wSig, pk, confirmCommit, proposeCommit);
+
+      final pkBytes = pk.expand((e) => e).toList();
+      record = {
+        'version': 1,
+        'wallet': wallet.hex,
+        'entryPoint': entryPoint.hex,
+        'networkChainId': chainId,
+        'userOpHash': userOpHashHex,
+        'nonce': nonceOnChain.toString(),
+        'index': index,
+        'signatureHybrid': '0x${w3.bytesToHex(op.signature, include0x: false)}',
+        'confirmNextCommit':
+            '0x${w3.bytesToHex(confirmCommit, include0x: false)}',
+        'proposeNextCommit':
+            '0x${w3.bytesToHex(proposeCommit, include0x: false)}',
+        'wotsPk': '0x${w3.bytesToHex(pkBytes, include0x: false)}',
+        'status': 'pending',
+        'createdAt': now,
+        'lastAttemptAt': now,
+      };
+      if (pending != null && decision == 'rebuild') {
+        record['createdAt'] = pending['createdAt'];
+      }
+      await store.save(chainId, wallet.hex, record);
+    }
+
+    final pendingStatus = pending == null ? 'absent' : 'present';
+    log([
+      'pendingIndex: $pendingStatus',
+      'nonce(): ${nonceOnChain.toString()}',
+      'userOpHash(draft): ${userOpHashHex.substring(0, 10)}',
+      'decision: $decision',
+    ].join('\n'));
+
+    final uoh = await bundler.sendUserOperation(op.toJson(), entryPoint.hex);
+    record ??= await store.load(chainId, wallet.hex);
+    if (record != null) {
+      record['status'] = 'sent';
+      record['lastAttemptAt'] = now;
+      await store.save(chainId, wallet.hex, record);
+    }
+    return uoh;
+  }
+
   Uint8List _encodeExecute(EthereumAddress to, BigInt value) {
     const execute = ContractFunction('execute', [
       FunctionParameter('to', AddressType()),
       FunctionParameter('value', UintType()),
       FunctionParameter('data', DynamicBytes()),
     ]);
     return execute.encodeCall([to, value, Uint8List(0)]);
   }
 }
+
+class Call {
+  final String to;
+  final BigInt value;
+  final Uint8List data;
+  Call(this.to, this.value, this.data);
+}
+
+Uint8List encodeExecuteBatch(List<Call> calls) {
+  final executeBatch = ContractFunction('executeBatch', [
+    FunctionParameter(
+        'calls',
+        DynamicLengthArray(
+            type: TupleType([AddressType(), UintType(), DynamicBytes()])))
+  ]);
+  final params = calls
+      .map((c) => [EthereumAddress.fromHex(c.to), c.value, c.data])
+      .toList();
+  return executeBatch.encodeCall([params]);
+}
+
+Future<Uint8List> buildTokenSendBatch({
+  required int chainId,
+  required String wallet,
+  required String tokenSymbol,
+  required String recipient,
+  required BigInt amountWeiLike,
+  required bool wantErc2612,
+  required bool wantPermit2,
+  required ChainTokens registry,
+}) async {
+  final tokenAddr = registry.tokenAddress(tokenSymbol, chainId)!;
+
+  final calls = <Call>[];
+
+  if (wantErc2612 && registry.feature(tokenSymbol, 'erc2612')) {
+    // Path A not supported for smart contract owners; fallback to transfer
+  }
+
+  if (wantPermit2 && registry.feature(tokenSymbol, 'permit2')) {
+    final permit2 = registry.permit2Address(chainId);
+    if (permit2 != null) {
+      // Path B not supported; fallback
+    }
+  }
+
+  calls.add(Call(
+      tokenAddr, BigInt.zero, Erc20.encodeTransfer(recipient, amountWeiLike)));
+
+  return encodeExecuteBatch(calls);
+}
diff --git a/mobile/pubspec.yaml b/mobile/pubspec.yaml
index 55a53a0d8f09eca7ab64a0b4ddc2c1e76095aaf4..2350cff87891f3231bb8eb86b364169a152df564 100644
--- a/mobile/pubspec.yaml
+++ b/mobile/pubspec.yaml
@@ -5,25 +5,26 @@ version: 0.1.0+1
 
 environment:
   sdk: ">=3.3.0 <4.0.0"
 
 dependencies:
   flutter:
     sdk: flutter
   http: ^1.2.1
   web3dart: ^2.7.3
   bip39: ^1.0.6
   bip32: ^2.0.0
   crypto: ^3.0.3
   flutter_secure_storage: ^9.0.0
   local_auth: ^2.3.0
   collection: ^1.18.0
 
 dev_dependencies:
   flutter_test:
     sdk: flutter
   lints: ^3.0.0
 
 flutter:
   uses-material-design: true
   assets:
     - assets/config.example.json
+    - assets/tokens.base.json
diff --git a/mobile/test/token_model_test.dart b/mobile/test/token_model_test.dart
new file mode 100644
index 0000000000000000000000000000000000000000..b4cc33b02f973b4ac80bec4491a081c162b56de3
--- /dev/null
+++ b/mobile/test/token_model_test.dart
@@ -0,0 +1,12 @@
+import 'package:flutter_test/flutter_test.dart';
+import 'package:pqc_wallet/models/token.dart';
+
+void main() {
+  TestWidgetsFlutterBinding.ensureInitialized();
+  test('loads token registry', () async {
+    final registry = await ChainTokens.load();
+    expect(registry.chainIdBaseSepolia(), 84532);
+    final addr = registry.tokenAddress('USDC', 84532);
+    expect(addr, isNotNull);
+  });
+}
 
EOF
)